---
title: <font size="5">**Proprioceptive accuracy and the degree of visuo-proprioceptive discrepancy do not influence the strength of rubber hand illusion**</font> 
author: "Pawel Motyka"
contact: "pawel.motyka@psych.uw.edu.pl"
date: "15th December 2018"
output: html_document
chunk_output_type: console

--- 
&nbsp;

List of sections:

1. Load required packages and data [S1](#S1)
2. Preprocess proprioception assessment data [S2](#S2)
3. Examine the relation between prioprioceptive accuracy and proprioceptive precision [S3](#S3)
4. Preprocess the subjective ratings of body ownership [S4](#S4)
5. The irrelevance of distance and proprioceptive accuracy for subjective ratings of body ownership [S5](#S5)
6. Load and preprocess electrodermal activity data [S6](#S6)
7. The irrelevance of distance and proprioceptive accuracy for electrodermal activity [S7](#S7)

--- 
<a name="S1"></a>
&nbsp;

#####**1. Load required packages and data**

```{r, message=FALSE}

# Load required packages 
library("plyr", quietly=TRUE)
library("gdata", quietly=TRUE)
library("BayesFactor", quietly=TRUE)
library("ggplot2", quietly=TRUE)
library("scales", quietly=TRUE)

# Specify data directory
data_dir <- 'N:/RHI_data'
setwd(data_dir)

# Load proprioceptive accuracy data
data <- read.csv("RHI_proprioception_assessment.csv")

# Load and reduce RHI questionnaire data
data_RHI <- read.table("RHI_questionnaire_data.csv", header = TRUE, sep = ",")

```

<a name="S2"></a>
&nbsp;

#####**2. Preprocess proprioception assessment data**

```{r}

# Create variable with target position class (factors)
data$target_class[data$target > 45 & data$target < 75] <- "60"
data$target_class[data$target > 75 & data$target < 105] <- "90"
data$target_class[data$target > 105 & data$target < 135] <- "120"
data$target_class <- factor(data$target_class)

# Check the expected number of observations for each traget position class
count(data$target_class == "60")
count(data$target_class == "90")
count(data$target_class == "120")

## Calculate reproduction error (RE: the difference between the target position and     reproduced one)
    data$diff <- data$target - data$performed
    #in absulute values
    data$diff_abs <- abs(data$target - data$performed)


## Create a data frame with performance of each participant accounting for different actions (abduction & flexion) and target positions (60, 90, and 120 degrees)
    
data_ID <- data.frame(ID = integer(0),
                      diff_M= numeric(0), # mean reproduction error (RE)
                      diff_M_abs = numeric(0), # mean absolute RE
                      diff_SD = numeric(0), # variance of the REs
                      diff_M_Ab = numeric(0), # mean RE - abduction only
                      diff_M_abs_Ab = numeric(0), # mean absolute RE - abduction
                      diff_SD_Ab = numeric(0), # variance of the REs - abduction
                      diff_M_Fl = numeric(0), # mean RE - flexion
                      diff_M_abs_Fl = numeric(0), # mean absolute RE - flexion
                      diff_SD_Fl = numeric(0), # variance of the REs - flexion
                      diff_M_abs_60_Ab = numeric(0), # mean absolute RE - abduction - 60°
                      diff_M_abs_90_Ab = numeric(0), #  mean absolute RE - abduction - 90°
                      diff_M_abs_120_Ab = numeric(0), # mean absolute RE - abduction - 120°
                      diff_SD_60_Ab = numeric(0), #  variance of the REs- abduction - 60°
                      diff_SD_90_Ab = numeric(0), #  variance of the REs - abduction - 90°
                      diff_SD_120_Ab = numeric(0), # variance of the REs- abduction - 120°
                      diff_M_abs_60_Fl = numeric(0), #  mean absolute RE  - flexion - 60°
                      diff_M_abs_90_Fl = numeric(0), #  mean absolute RE - flexion - 90°
                      diff_M_abs_120_Fl = numeric(0), # mean absolute RE - flexion - 120°
                      diff_SD_60_Fl = numeric(0), #  variance of the REs- flexion - 60°
                      diff_SD_90_Fl = numeric(0), #  variance of the REs - flexion - 90°
                      diff_SD_120_Fl = numeric(0)) # variance of the REs- flexion - 120°


# extract the list of participants
ID_list <- unique(data$ID)

for (p in ID_list) { # LOOP PARTICIPANTS (p)
  
 # Calculate general results
 diff_M <- mean(data$diff[data$ID == p]) # mean reproduction error (RE) 
 diff_M_abs <- mean(data$diff_abs[data$ID == p]) # mean absolute RE
 diff_SD <- sd(data$diff[data$ID == p]) # variance of the REs
 
 # Results for abduction only
 diff_M_Ab <- mean(data$diff[data$ID == p & data$Task_type == "abduction"])
 diff_M_abs_Ab <- mean(data$diff_abs[data$ID == p & data$Task_type == "abduction"])
 diff_SD_Ab <- sd(data$diff[data$ID == p & data$Task_type == "abduction"])
 
 # Results for flexion only
 diff_M_Fl <- mean(data$diff[data$ID == p & data$Task_type == "flexion"])
 diff_M_abs_Fl <- mean(data$diff_abs[data$ID == p & data$Task_type == "flexion"])
 diff_SD_Fl <- sd(data$diff[data$ID == p & data$Task_type == "flexion"])
 
 # Results for different target positions (60, 90, 120 degrees)
    # Abduction
    diff_M_abs_60_Ab <- mean(data$diff_abs[data$ID == p & data$target_class == "60" & data$Task_type == "abduction"]) 
    diff_M_abs_90_Ab <- mean(data$diff_abs[data$ID == p & data$target_class == "90" & data$Task_type == "abduction"])
    diff_M_abs_120_Ab <- mean(data$diff_abs[data$ID == p & data$target_class == "120" & data$Task_type == "abduction"])
    diff_SD_60_Ab <- sd(data$diff[data$ID == p & data$target_class == "60" & data$Task_type == "abduction"]) 
    diff_SD_90_Ab <- sd(data$diff[data$ID == p & data$target_class == "90" & data$Task_type == "abduction"])
    diff_SD_120_Ab <- sd(data$diff[data$ID == p & data$target_class == "120" & data$Task_type == "abduction"])
    # Flexion
    diff_M_abs_60_Fl <- mean(data$diff_abs[data$ID == p & data$target_class == "60" & data$Task_type == "flexion"]) 
    diff_M_abs_90_Fl <- mean(data$diff_abs[data$ID == p & data$target_class == "90" & data$Task_type == "flexion"])
    diff_M_abs_120_Fl <- mean(data$diff_abs[data$ID == p & data$target_class == "120" & data$Task_type == "flexion"])
    diff_SD_60_Fl <- sd(data$diff[data$ID == p & data$target_class == "60" & data$Task_type == "flexion"]) 
    diff_SD_90_Fl <- sd(data$diff[data$ID == p & data$target_class == "90" & data$Task_type == "flexion"])
    diff_SD_120_Fl <- sd(data$diff[data$ID == p & data$target_class == "120" & data$Task_type == "flexion"])

    # Create a data frame
    data_ID[nrow(data_ID)+1,] <- c(p,diff_M,diff_M_abs, diff_SD, diff_M_Ab, diff_M_abs_Ab,  diff_SD_Ab, diff_M_Fl, diff_M_abs_Fl, diff_SD_Fl, diff_M_abs_60_Ab, diff_M_abs_90_Ab, diff_M_abs_120_Ab, diff_SD_60_Ab, diff_SD_90_Ab, diff_SD_120_Ab, diff_M_abs_60_Fl, diff_M_abs_90_Fl, diff_M_abs_120_Fl, diff_SD_60_Fl, diff_SD_90_Fl, diff_SD_120_Fl)

} # END: LOOP PARTICIPANTS (p)

## Standardize the mean reproduction errors to see outliers

# normalize the main prioprioceptive accuracy measure (mean reproduction error - absolute value)
data_ID$diff_Z <- (data_ID$diff_M_abs - mean(data_ID$diff_M_abs))/sd(data_ID$diff_M_abs)

# look for outliers (according to a cut-off criterion of three standard deviations below or above sample mean)
data_ID$ID[data_ID$diff_Z > 3 | data_ID$diff_Z < -3]

# remove an outlier (ID 32)  
data_ID <- data_ID[data_ID$ID!=32,]

```

<a name="S3"></a>
&nbsp;

#####**3. Examine the relation between prioprioceptive accuracy and proprioceptive precision**


```{r}

# Show descriptive statistics for:
  # proprioceptive accuracy (mean absolute reproduction error)
  mean(data_ID$diff_M_abs)
  sd(data_ID$diff_M_abs)
  range(data_ID$diff_M_abs)
  # proprioceptive precision (variance of reproduction errors)
  mean(data_ID$diff_SD)
  sd(data_ID$diff_SD)
  range(data_ID$diff_SD)

# test normality of the prioprioceptive variables
shapiro.test(data_ID$diff_M_abs)
shapiro.test(data_ID$diff_SD)

# run correlation
cor.test(data_ID$diff_M_abs, data_ID$diff_SD, method = "spearman")

# Plot relation between proprioceptive accuracy and precison
FigS1 <- ggplot(data = data_ID, aes(x = diff_M_abs, y = diff_SD)) + geom_smooth(col = "grey8", method = "lm", level=0.95, alpha = 0.7) + geom_point(col = "grey 15", alpha = 0.8) + labs(x = "Proprioceptive (in)accuracy \n (mean reproduction error in degrees)" , y = "Proprioceptive (im)precision \n (variance of the errors)") + scale_fill_manual() + theme_classic() + theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 18), axis.text=element_text(size=16), axis.title=element_text(size=16))
FigS1


```

<a name="S4"></a>
&nbsp;

#####**4. Preprocess the subjective ratings of body ownership**

```{r}

# Merging proprioceptive data with Rubber Hand Illusion data
data_ID <- merge(data_ID, data_RHI, by = 'ID')

# Participants: main statistics
mean(data_ID$age)
sd(data_ID$age)
count(data_ID$sex[data_ID$sex=="K"]) # K = female

## To measure the subjective strength of the illusion, we adopted questionnaire items (on 7-point Likert scale) and computation of an illusion strength index from Abdulkarim and Ehrsson’s (2016) study. S1-S3 items served as illusion probes, whereas S4-S6 were used as controlling for task demand or suggestibility effects. The illusion strength index was defined as the difference between the means of the illusion probes (S1-S3) and the control items (S4-S6), and calculated separately for synchronous and asynchronous conditions. 

# Synchronous Condition
data_ID$illusion_mean_syn <- (data_ID$Q1_syn + data_ID$Q2_syn + data_ID$Q3_syn)/3 # illusion items
data_ID$control_mean_syn <- (data_ID$Q4_syn + data_ID$Q5_syn + data_ID$Q6_syn)/3 # control items
data_ID$str_syn <- data_ID$illusion_mean_syn - data_ID$control_mean_syn # illusion index

# Asynchronous Condition
data_ID$illusion_mean_asyn <- (data_ID$Q1_asyn + data_ID$Q2_asyn + data_ID$Q3_asyn)/3 # illusion items
data_ID$control_mean_asyn <- (data_ID$Q4_asyn + data_ID$Q5_asyn + data_ID$Q6_asyn)/3 # control items
data_ID$str_asyn <- data_ID$illusion_mean_asyn - data_ID$control_mean_asyn # illusion index

# Format decimal places
round(data_ID$str_syn, digits=5)
round(data_ID$str_asyn, digits=5)

# Save experimental conditions (Far/Close position of the real hand) as factor
data_ID$Gr <- as.factor(data_ID$Gr)

#write.csv(data_ID, "RHI_preprocessed_behavioral_data(output_from_section_4)", row.names=FALSE) 
```


<a name="S5"></a>
&nbsp;

#####**5. The irrelevance of distance and proprioceptive accuracy for subjective ratings of body ownership**

```{r}

data_ID <- read.csv("RHI_preprocessed_behavioral_data(output_from_section_4)")

# Test normality of the illusion strength indexes
shapiro.test(data_ID$str_syn)
shapiro.test(data_ID$str_asyn)

# Test differences bewteen synchronous and asynchronous conditions (within-subjects factor)
t.test(data_ID$str_syn, data_ID$str_asyn, paired = TRUE, conf.level = 0.95, exact= F)

# show descriptive statistics for synchronous and asynchronous conditions
mean(data_ID$str_syn)
sd(data_ID$str_syn)
mean(data_ID$str_asyn)
sd(data_ID$str_asyn)

# Linear regression model - predictors: proprioceptive accuracy (continuous variable) and distance (between-subjects factor: “far” vs “close” distance between hands)
model <- lm(str_syn ~ Gr + diff_M_abs + Gr:diff_M_abs, data = data_ID)
summary(model)

# Compute Bayes factors for specific linear models (with and without interaction)
Full <- lmBF(str_syn ~ Gr + diff_M_abs + Gr:diff_M_abs, data = data_ID) # Full model
noInteraction <- lmBF(str_syn ~  Gr + diff_M_abs, data = data_ID) # Model without interaction

# Plot preliminary version
allBFs <- c(Full,noInteraction)
allBFs
plot(allBFs)

# Save Bayes Factors as single values
full_sub <- as.numeric(as.vector(Full)) # Full model
no_int_sub <- as.numeric(as.vector(noInteraction)) # Model without interaction

```

<a name="S6"></a>
&nbsp;

#####**6. Load and preprocess electrodermal activity data**


```{r}

### During every attack, an amplitude of SCR was analyzed in a time bracket encompassing 1-6 seconds after stimulus onset (Figner & Murphy, 2010). The strength of the illusion was operationalized as a mean SCR amplitude of five knife attacks

## Load and preprocess physiological data for each paricipant within the loop

for (p in unique(data_ID$ID)) { ifelse(p < 10, ID_str <- paste('0', p, sep = ''), ID_str <- p)  
  
  # load physiological data for each participant
  gsr <- read.table(paste('RHI_',ID_str,'.txt', sep=''), header = F, sep = "\t", fill = TRUE, stringsAsFactors = FALSE)
  
  # specify names of variables: time & amplitude
  names(gsr)=c("time","amp")
  
  # recalculate time values into seconds
  gsr$time <- gsr$time * 60
  
  # read the list of events (threatening the rubber hand) from synchronous condition
  events_syn <- read.table(paste('RHI_',ID_str,'_s_events.txt', sep=''), header = F, sep = " ", fill = TRUE, stringsAsFactors = FALSE)
  names(events_syn)=c("event")
  
  # read the list of events (threatening the rubber hand) from asynchronous condition
  events_asyn <- read.table(paste('RHI_',ID_str,'_a_events.txt', sep=''), header = F, sep = " ", fill = TRUE, stringsAsFactors = FALSE)
  names(events_asyn)=c("event")
  
  # bind the lists of events 
  events <- rbind(events_syn, events_asyn)
  
  # reduce physiological data into the interval from the beginnig of illusion elicitation during synchronous condition (40 seconds before the first knife attack) until the end of illusion elicitation during asynchronous condition (+6 seconds after the last knife attack)  
  gsr <- gsr[which(gsr$time >= (min(events$event) - 40) & gsr$time <= (max(events$event) + 6)),]

    ##Optional plotting of SCR signal
    #require(hexbin)
    #x <- hexbin(gsr, xbins = 5000, ybnds = range(gsr$amp), shape = 1/3)
    #plot(x)
  
  # normalize the data using log(SCR+1) correction (Braithwaite, Watson, and Dewe, 2017) 
  gsr$amp <- log(gsr$amp + 1)
  
  # standardize the amplitude of SCR into z-scores based on each participant’s mean and standard deviation (Braithwaite, Watson, and Dewe, 2017)
  gsr_mean <- mean(gsr$amp)
  gsr_sd <- sd(gsr$amp)
  gsr$amp <- (gsr$amp - gsr_mean)/gsr_sd

  ### Derive SCR amplitudes in time brackets encompassing 1-6 seconds after stimulus onset. To exclude the possibility that calculated value would reflect the steepness of continuous decrease in voltage rather than genuine amplitude (which could occur if threatening the rubber hand did not evoked any arousal, for all events, if maximal value was observed during the first second of time bracket the amplitude was not calculated and 0 was put instead (signifying a lack of response to threatening event). 
  
  ## Synchronous condition

  # Event 1
  ifelse(max(gsr$amp[gsr$time >= events_syn$event[1] + 1 & gsr$time <= (events_syn$event[1] + 6)]) == max(gsr$amp[gsr$time >= events_syn$event[1] + 1 & gsr$time <= (events_syn$event[1] + 2)]), data_ID$s1_syn[data_ID$ID == p] <- 0, data_ID$s1_syn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_syn$event[1] + 1 & gsr$time <= (events_syn$event[1] + 6) ]) - min(gsr$amp[gsr$time >= events_syn$event[1] + 1 & gsr$time <= (events_syn$event[1] + 6) ]))
  
  # Event 2
  ifelse(max(gsr$amp[gsr$time >= events_syn$event[2] + 1 & gsr$time <= (events_syn$event[2] + 6)]) == max(gsr$amp[gsr$time >= events_syn$event[2] + 1 & gsr$time <= (events_syn$event[2] + 2)]), data_ID$s2_syn[data_ID$ID == p] <- 0, data_ID$s2_syn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_syn$event[2] + 1 & gsr$time <= (events_syn$event[2] + 6) ]) - min(gsr$amp[gsr$time >= events_syn$event[2] + 1 & gsr$time <= (events_syn$event[2] + 6) ]))
  
  # Event 3
  ifelse(max(gsr$amp[gsr$time >= events_syn$event[3] + 1 & gsr$time <= (events_syn$event[3] + 6)]) == max(gsr$amp[gsr$time >= events_syn$event[3] + 1 & gsr$time <= (events_syn$event[3] + 2)]), data_ID$s3_syn[data_ID$ID == p] <- 0, data_ID$s3_syn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_syn$event[3] + 1 & gsr$time <= (events_syn$event[3] + 6) ]) - min(gsr$amp[gsr$time >= events_syn$event[3] + 1 & gsr$time <= (events_syn$event[3] + 6) ]))
  
  # Event 4
  ifelse(max(gsr$amp[gsr$time >= events_syn$event[4] + 1 & gsr$time <= (events_syn$event[4] + 6)]) == max(gsr$amp[gsr$time >= events_syn$event[4] + 1 & gsr$time <= (events_syn$event[4] + 2)]), data_ID$s4_syn[data_ID$ID == p] <- 0, data_ID$s4_syn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_syn$event[4] + 1 & gsr$time <= (events_syn$event[4] + 6) ]) - min(gsr$amp[gsr$time >= events_syn$event[4] + 1 & gsr$time <= (events_syn$event[4] + 6) ]))
  
  # Event 5
  ifelse(max(gsr$amp[gsr$time >= events_syn$event[5] + 1 & gsr$time <= (events_syn$event[5] + 6)]) == max(gsr$amp[gsr$time >= events_syn$event[5] + 1 & gsr$time <= (events_syn$event[5] + 2)]), data_ID$s5_syn[data_ID$ID == p] <- 0, data_ID$s5_syn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_syn$event[5] + 1 & gsr$time <= (events_syn$event[5] + 6) ]) - min(gsr$amp[gsr$time >= events_syn$event[5] + 1 & gsr$time <= (events_syn$event[5] + 6) ]))


  ## Asynchronous condition

 # Event 1
  ifelse(max(gsr$amp[gsr$time >= events_asyn$event[1] + 1 & gsr$time <= (events_asyn$event[1] + 6)]) == max(gsr$amp[gsr$time >= events_asyn$event[1] + 1 & gsr$time <= (events_asyn$event[1] + 2)]), data_ID$s1_asyn[data_ID$ID == p] <- 0, data_ID$s1_asyn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_asyn$event[1] + 1 & gsr$time <= (events_asyn$event[1] + 6) ]) - min(gsr$amp[gsr$time >= events_asyn$event[1] + 1 & gsr$time <= (events_asyn$event[1] + 6) ]))
  
  # Event 2
  ifelse(max(gsr$amp[gsr$time >= events_asyn$event[2] + 1 & gsr$time <= (events_asyn$event[2] + 6)]) == max(gsr$amp[gsr$time >= events_asyn$event[2] + 1 & gsr$time <= (events_asyn$event[2] + 2)]), data_ID$s2_asyn[data_ID$ID == p] <- 0, data_ID$s2_asyn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_asyn$event[2] + 1 & gsr$time <= (events_asyn$event[2] + 6) ]) - min(gsr$amp[gsr$time >= events_asyn$event[2] + 1 & gsr$time <= (events_asyn$event[2] + 6) ]))
  
  # Event 3
  ifelse(max(gsr$amp[gsr$time >= events_asyn$event[3] + 1 & gsr$time <= (events_asyn$event[3] + 6)]) == max(gsr$amp[gsr$time >= events_asyn$event[3] + 1 & gsr$time <= (events_asyn$event[3] + 2)]), data_ID$s3_asyn[data_ID$ID == p] <- 0, data_ID$s3_asyn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_asyn$event[3] + 1 & gsr$time <= (events_asyn$event[3] + 6) ]) - min(gsr$amp[gsr$time >= events_asyn$event[3] + 1 & gsr$time <= (events_asyn$event[3] + 6) ]))
  
  # Event 4
  ifelse(max(gsr$amp[gsr$time >= events_asyn$event[4] + 1 & gsr$time <= (events_asyn$event[4] + 6)]) == max(gsr$amp[gsr$time >= events_asyn$event[4] + 1 & gsr$time <= (events_asyn$event[4] + 2)]), data_ID$s4_asyn[data_ID$ID == p] <- 0, data_ID$s4_asyn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_asyn$event[4] + 1 & gsr$time <= (events_asyn$event[4] + 6) ]) - min(gsr$amp[gsr$time >= events_asyn$event[4] + 1 & gsr$time <= (events_asyn$event[4] + 6) ]))
  
  # Event 5
  ifelse(max(gsr$amp[gsr$time >= events_asyn$event[5] + 1 & gsr$time <= (events_asyn$event[5] + 6)]) == max(gsr$amp[gsr$time >= events_asyn$event[5] + 1 & gsr$time <= (events_asyn$event[5] + 2)]), data_ID$s5_asyn[data_ID$ID == p] <- 0, data_ID$s5_asyn[data_ID$ID == p] <- max(gsr$amp[gsr$time >= events_asyn$event[5] + 1 & gsr$time <= (events_asyn$event[5] + 6) ]) - min(gsr$amp[gsr$time >= events_asyn$event[5] + 1 & gsr$time <= (events_asyn$event[5] + 6) ]))


} ## Close the loop

### Detect events with maximal value observed during the first second of the time bracket (i.e., without gradually rising amplitude)

## Synchronous condition

# derive number of such cases for each event (1-5)
inv1s <- length(data_ID$ID[data_ID$s1_syn == 0]) #event1
inv2s <- length(data_ID$ID[data_ID$s2_syn == 0]) #event2
inv3s <- length(data_ID$ID[data_ID$s3_syn == 0]) #event3
inv4s <- length(data_ID$ID[data_ID$s4_syn == 0]) #event4
inv5s <- length(data_ID$ID[data_ID$s5_syn == 0]) #event5

# sum of these cases
sum_invalid_amplitudes_syn <- inv1s + inv2s + inv3s + inv4s + inv5s 
sum_invalid_amplitudes_syn

#derive number of unique participants concerned 
s1 <- data_ID$ID[data_ID$s1_syn == 0] #event1
s2 <- data_ID$ID[data_ID$s2_syn == 0] #event2
s3 <- data_ID$ID[data_ID$s3_syn == 0] #event3
s4 <- data_ID$ID[data_ID$s4_syn == 0] #event4
s5 <- data_ID$ID[data_ID$s5_syn == 0] #event5
List_ID_syn <- c(s1,s2,s3,s4,s5)
length(unique(List_ID_syn))

## Synchronous condition

# derive number of such cases for each event (1-5)
inv1a <- length(data_ID$ID[data_ID$s1_asyn == 0]) #event1
inv2a <- length(data_ID$ID[data_ID$s2_asyn == 0]) #event2
inv3a <- length(data_ID$ID[data_ID$s3_asyn == 0]) #event3
inv4a <- length(data_ID$ID[data_ID$s4_asyn == 0]) #event4
inv5a <- length(data_ID$ID[data_ID$s5_asyn == 0]) #event5

# sum of these cases
sum_invalid_amplitudes_asyn <- inv1a + inv2a + inv3a + inv4a + inv5a 
sum_invalid_amplitudes_asyn

#derive number of unique participants concerned 
a1 <- data_ID$ID[data_ID$s1_asyn == 0] #event1
a2 <- data_ID$ID[data_ID$s2_asyn == 0] #event2
a3 <- data_ID$ID[data_ID$s3_asyn == 0] #event3
a4 <- data_ID$ID[data_ID$s4_asyn == 0] #event4
a5 <- data_ID$ID[data_ID$s5_asyn == 0] #event5
List_ID_asyn <- c(a1,a2,a3,a4,a5)
length(unique(List_ID_asyn))

## The strength of the illusion was operationalized as a mean SCR amplitude of five knife attacks
data_ID$amp_syn <- (data_ID$s1_syn + data_ID$s2_syn + data_ID$s3_syn + data_ID$s4_syn + data_ID$s5_syn) / 5 # synchronous condition
data_ID$amp_asyn <- (data_ID$s1_asyn + data_ID$s2_asyn + data_ID$s3_asyn + data_ID$s4_asyn + data_ID$s5_asyn) / 5 # asynchronous condition

#write.csv(data_ID, "RHI_preprocessed_physiological_data(output_from_section_6)", row.names=FALSE) 

```

<a name="S7"></a>
&nbsp;

#####**7. The irrelevance of distance and proprioceptive accuracy for electrodermal activity**

```{r}

data_ID <- read.csv("RHI_preprocessed_physiological_data(output_from_section_6)")

# Test normality of mean SCR amplitudes 
shapiro.test(data_ID$amp_syn) # synchronus 
shapiro.test(data_ID$amp_asyn) # asynchronous

# Test differences between synchronous and asynchronous conditions
wilcox.test(data_ID$amp_syn, data_ID$amp_asyn, paired = T, exact = F, alternative = "two.sided")

## Show descriptive statistics for synchronous and asynchronous conditions
median(data_ID$amp_syn)
mean(data_ID$amp_syn)
sd(data_ID$amp_syn)
median(data_ID$amp_asyn)
mean(data_ID$amp_asyn)
sd(data_ID$amp_asyn)

# Linear regression model - predictors: proprioceptive accuracy (continuous variable) and distance (between-subjects factor: “far” vs “close” distance between hands)
model_syn <- lm(amp_syn ~ Gr + diff_M_abs + Gr:diff_M_abs, data = data_ID)
summary(model_syn)

# Compute Bayes factors for specific linear models (with and without interaction)
Full_ea <- lmBF(amp_syn ~ Gr + diff_M_abs + Gr:diff_M_abs, data = data_ID)
noInteraction_ea <- lmBF(amp_syn ~  Gr + diff_M_abs, data = data_ID)

# Plot default version
allBFs <- c(Full_ea,noInteraction_ea)
allBFs
plot(allBFs)

# Save Bayes Factors as single values
full_ea <- as.numeric(as.vector(Full_ea))
no_int_ea <- as.numeric(as.vector(noInteraction_ea))

# Create a vector with all Bayes Factors 
BFs <- c(no_int_ea, full_ea, no_int_sub, full_sub)

## Plot Bayes Factors: Regression models for subjective ratings of body ownership and electrodermal activity
barplot(BFs, border = NA, space = 0.6, log = "x", horiz = T, xlim = c(0.033,3), xaxt="n", xlab = "Bayes Factor", col = c("orange", "orange", "royalblue", "royalblue", alpha = 0.7) , cex.lab = 1.3, cex.axis = 1.5)
xtick<-c(0.033,0.1,0.333,1,3)
lab = c("1/30", "1/10", "1/3", "1", "3")
axis(side=1, at=xtick, labels = lab, cex.axis = 1.2)
title(main = "Regression Models for \n Subjective Body Ownership and Electrodermal Activity",  font = 4, cex.main = 1.2)
abline(v= 0.033, col=alpha(rgb(0.2,0.2,0.2), 0.8), lty = 3, lwd = 1.5)
abline(v= 0.1, col=alpha(rgb(0.2,0.2,0.2), 0.8), lty = 3, lwd = 1.5)
abline(v= 0.333, col=alpha(rgb(0.2,0.2,0.2), 0.8), lty = 3, lwd = 1.5)
abline(v = 1, col=alpha(rgb(0.2,0.2,0.2), 0.8), lty = 3, lwd = 1.5)  
abline(v = 3, col=alpha(rgb(0.2,0.2,0.2), 0.8), lty = 3, lwd = 1.5)  

# Print Bayes Factors (starting from the top bar)
full_sub # full model with interaction - subjective body ownership
no_int_sub # without interaction - subjective body ownership
full_ea # full model with interaction - electrodermal activity
no_int_ea # without interaction - electrodermal activity

```







